{"ast":null,"code":"export const createEmptyBoard = (width, height) => {\n  const board = [];\n  for (let y = 0; y < height; y++) {\n    const row = [];\n    for (let x = 0; x < width; x++) {\n      row.push({\n        isMine: false,\n        isRevealed: false,\n        isFlagged: false,\n        neighborMines: 0,\n        x,\n        y\n      });\n    }\n    board.push(row);\n  }\n  return board;\n};\nexport const placeMines = (board, mineCount, firstClickX, firstClickY) => {\n  const newBoard = board.map(row => row.map(cell => ({\n    ...cell\n  })));\n  const {\n    length: height\n  } = newBoard;\n  const {\n    length: width\n  } = newBoard[0];\n  let minesPlaced = 0;\n  const forbiddenPositions = new Set();\n\n  // Prevent mines around the first click (3x3 area)\n  for (let dy = -1; dy <= 1; dy++) {\n    for (let dx = -1; dx <= 1; dx++) {\n      const nx = firstClickX + dx;\n      const ny = firstClickY + dy;\n      if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\n        forbiddenPositions.add(`${nx},${ny}`);\n      }\n    }\n  }\n  while (minesPlaced < mineCount) {\n    const x = Math.floor(Math.random() * width);\n    const y = Math.floor(Math.random() * height);\n    const posKey = `${x},${y}`;\n    if (!newBoard[y][x].isMine && !forbiddenPositions.has(posKey)) {\n      newBoard[y][x].isMine = true;\n      minesPlaced++;\n    }\n  }\n  return calculateNeighborMines(newBoard);\n};\nexport const calculateNeighborMines = board => {\n  const newBoard = board.map(row => row.map(cell => ({\n    ...cell\n  })));\n  const {\n    length: height\n  } = newBoard;\n  const {\n    length: width\n  } = newBoard[0];\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      if (!newBoard[y][x].isMine) {\n        let mineCount = 0;\n\n        // Check all 8 adjacent cells\n        for (let dy = -1; dy <= 1; dy++) {\n          for (let dx = -1; dx <= 1; dx++) {\n            if (dx === 0 && dy === 0) continue; // Skip the cell itself\n\n            const nx = x + dx;\n            const ny = y + dy;\n            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\n              if (newBoard[ny][nx].isMine) {\n                mineCount++;\n              }\n            }\n          }\n        }\n        newBoard[y][x].neighborMines = mineCount;\n      }\n    }\n  }\n  return newBoard;\n};\nexport const revealCell = (board, x, y) => {\n  const newBoard = board.map(row => row.map(cell => ({\n    ...cell\n  })));\n  const {\n    length: height\n  } = newBoard;\n  const {\n    length: width\n  } = newBoard[0];\n  if (x < 0 || x >= width || y < 0 || y >= height) return newBoard;\n  const cell = newBoard[y][x];\n  if (cell.isRevealed || cell.isFlagged) return newBoard;\n  cell.isRevealed = true;\n\n  // If it's an empty cell (no neighboring mines), reveal all adjacent cells\n  if (!cell.isMine && cell.neighborMines === 0) {\n    for (let dy = -1; dy <= 1; dy++) {\n      for (let dx = -1; dx <= 1; dx++) {\n        if (dx === 0 && dy === 0) continue;\n        const nx = x + dx;\n        const ny = y + dy;\n        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\n          revealCellRecursive(newBoard, nx, ny, width, height);\n        }\n      }\n    }\n  }\n  return newBoard;\n};\nconst revealCellRecursive = (board, x, y, width, height) => {\n  if (x < 0 || x >= width || y < 0 || y >= height) return;\n  const cell = board[y][x];\n  if (cell.isRevealed || cell.isFlagged || cell.isMine) return;\n  cell.isRevealed = true;\n\n  // If it's an empty cell, continue revealing neighbors\n  if (cell.neighborMines === 0) {\n    for (let dy = -1; dy <= 1; dy++) {\n      for (let dx = -1; dx <= 1; dx++) {\n        if (dx === 0 && dy === 0) continue;\n        const nx = x + dx;\n        const ny = y + dy;\n        revealCellRecursive(board, nx, ny, width, height);\n      }\n    }\n  }\n};\nexport const toggleFlag = (board, x, y) => {\n  const newBoard = board.map(row => row.map(cell => ({\n    ...cell\n  })));\n  const cell = newBoard[y][x];\n  if (!cell.isRevealed) {\n    cell.isFlagged = !cell.isFlagged;\n  }\n  return newBoard;\n};\nexport const checkWinCondition = board => {\n  for (const row of board) {\n    for (const cell of row) {\n      // If there's an unrevealed cell that's not a mine, game is not won\n      if (!cell.isMine && !cell.isRevealed) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\nexport const revealAllMines = board => {\n  return board.map(row => row.map(cell => ({\n    ...cell,\n    isRevealed: cell.isMine ? true : cell.isRevealed\n  })));\n};\nexport const countFlags = board => {\n  let flagCount = 0;\n  for (const row of board) {\n    for (const cell of row) {\n      if (cell.isFlagged) {\n        flagCount++;\n      }\n    }\n  }\n  return flagCount;\n};\nexport const getDefaultConfig = () => ({\n  width: 9,\n  height: 9,\n  mines: 10\n});","map":{"version":3,"names":["createEmptyBoard","width","height","board","y","row","x","push","isMine","isRevealed","isFlagged","neighborMines","placeMines","mineCount","firstClickX","firstClickY","newBoard","map","cell","length","minesPlaced","forbiddenPositions","Set","dy","dx","nx","ny","add","Math","floor","random","posKey","has","calculateNeighborMines","revealCell","revealCellRecursive","toggleFlag","checkWinCondition","revealAllMines","countFlags","flagCount","getDefaultConfig","mines"],"sources":["C:/Users/Vitth/Projects/minesweeper-react/src/gameUtils.ts"],"sourcesContent":["import { Cell, GameConfig } from './types';\r\n\r\nexport const createEmptyBoard = (width: number, height: number): Cell[][] => {\r\n  const board: Cell[][] = [];\r\n  for (let y = 0; y < height; y++) {\r\n    const row: Cell[] = [];\r\n    for (let x = 0; x < width; x++) {\r\n      row.push({\r\n        isMine: false,\r\n        isRevealed: false,\r\n        isFlagged: false,\r\n        neighborMines: 0,\r\n        x,\r\n        y,\r\n      });\r\n    }\r\n    board.push(row);\r\n  }\r\n  return board;\r\n};\r\n\r\nexport const placeMines = (\r\n  board: Cell[][],\r\n  mineCount: number,\r\n  firstClickX: number,\r\n  firstClickY: number\r\n): Cell[][] => {\r\n  const newBoard = board.map(row => row.map(cell => ({ ...cell })));\r\n  const { length: height } = newBoard;\r\n  const { length: width } = newBoard[0];\r\n  \r\n  let minesPlaced = 0;\r\n  const forbiddenPositions = new Set<string>();\r\n  \r\n  // Prevent mines around the first click (3x3 area)\r\n  for (let dy = -1; dy <= 1; dy++) {\r\n    for (let dx = -1; dx <= 1; dx++) {\r\n      const nx = firstClickX + dx;\r\n      const ny = firstClickY + dy;\r\n      if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\r\n        forbiddenPositions.add(`${nx},${ny}`);\r\n      }\r\n    }\r\n  }\r\n  \r\n  while (minesPlaced < mineCount) {\r\n    const x = Math.floor(Math.random() * width);\r\n    const y = Math.floor(Math.random() * height);\r\n    const posKey = `${x},${y}`;\r\n    \r\n    if (!newBoard[y][x].isMine && !forbiddenPositions.has(posKey)) {\r\n      newBoard[y][x].isMine = true;\r\n      minesPlaced++;\r\n    }\r\n  }\r\n  \r\n  return calculateNeighborMines(newBoard);\r\n};\r\n\r\nexport const calculateNeighborMines = (board: Cell[][]): Cell[][] => {\r\n  const newBoard = board.map(row => row.map(cell => ({ ...cell })));\r\n  const { length: height } = newBoard;\r\n  const { length: width } = newBoard[0];\r\n  \r\n  for (let y = 0; y < height; y++) {\r\n    for (let x = 0; x < width; x++) {\r\n      if (!newBoard[y][x].isMine) {\r\n        let mineCount = 0;\r\n        \r\n        // Check all 8 adjacent cells\r\n        for (let dy = -1; dy <= 1; dy++) {\r\n          for (let dx = -1; dx <= 1; dx++) {\r\n            if (dx === 0 && dy === 0) continue; // Skip the cell itself\r\n            \r\n            const nx = x + dx;\r\n            const ny = y + dy;\r\n            \r\n            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\r\n              if (newBoard[ny][nx].isMine) {\r\n                mineCount++;\r\n              }\r\n            }\r\n          }\r\n        }\r\n        \r\n        newBoard[y][x].neighborMines = mineCount;\r\n      }\r\n    }\r\n  }\r\n  \r\n  return newBoard;\r\n};\r\n\r\nexport const revealCell = (board: Cell[][], x: number, y: number): Cell[][] => {\r\n  const newBoard = board.map(row => row.map(cell => ({ ...cell })));\r\n  const { length: height } = newBoard;\r\n  const { length: width } = newBoard[0];\r\n  \r\n  if (x < 0 || x >= width || y < 0 || y >= height) return newBoard;\r\n  \r\n  const cell = newBoard[y][x];\r\n  if (cell.isRevealed || cell.isFlagged) return newBoard;\r\n  \r\n  cell.isRevealed = true;\r\n  \r\n  // If it's an empty cell (no neighboring mines), reveal all adjacent cells\r\n  if (!cell.isMine && cell.neighborMines === 0) {\r\n    for (let dy = -1; dy <= 1; dy++) {\r\n      for (let dx = -1; dx <= 1; dx++) {\r\n        if (dx === 0 && dy === 0) continue;\r\n        \r\n        const nx = x + dx;\r\n        const ny = y + dy;\r\n        \r\n        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\r\n          revealCellRecursive(newBoard, nx, ny, width, height);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  return newBoard;\r\n};\r\n\r\nconst revealCellRecursive = (\r\n  board: Cell[][],\r\n  x: number,\r\n  y: number,\r\n  width: number,\r\n  height: number\r\n): void => {\r\n  if (x < 0 || x >= width || y < 0 || y >= height) return;\r\n  \r\n  const cell = board[y][x];\r\n  if (cell.isRevealed || cell.isFlagged || cell.isMine) return;\r\n  \r\n  cell.isRevealed = true;\r\n  \r\n  // If it's an empty cell, continue revealing neighbors\r\n  if (cell.neighborMines === 0) {\r\n    for (let dy = -1; dy <= 1; dy++) {\r\n      for (let dx = -1; dx <= 1; dx++) {\r\n        if (dx === 0 && dy === 0) continue;\r\n        \r\n        const nx = x + dx;\r\n        const ny = y + dy;\r\n        \r\n        revealCellRecursive(board, nx, ny, width, height);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nexport const toggleFlag = (board: Cell[][], x: number, y: number): Cell[][] => {\r\n  const newBoard = board.map(row => row.map(cell => ({ ...cell })));\r\n  const cell = newBoard[y][x];\r\n  \r\n  if (!cell.isRevealed) {\r\n    cell.isFlagged = !cell.isFlagged;\r\n  }\r\n  \r\n  return newBoard;\r\n};\r\n\r\nexport const checkWinCondition = (board: Cell[][]): boolean => {\r\n  for (const row of board) {\r\n    for (const cell of row) {\r\n      // If there's an unrevealed cell that's not a mine, game is not won\r\n      if (!cell.isMine && !cell.isRevealed) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n  return true;\r\n};\r\n\r\nexport const revealAllMines = (board: Cell[][]): Cell[][] => {\r\n  return board.map(row =>\r\n    row.map(cell => ({\r\n      ...cell,\r\n      isRevealed: cell.isMine ? true : cell.isRevealed,\r\n    }))\r\n  );\r\n};\r\n\r\nexport const countFlags = (board: Cell[][]): number => {\r\n  let flagCount = 0;\r\n  for (const row of board) {\r\n    for (const cell of row) {\r\n      if (cell.isFlagged) {\r\n        flagCount++;\r\n      }\r\n    }\r\n  }\r\n  return flagCount;\r\n};\r\n\r\nexport const getDefaultConfig = (): GameConfig => ({\r\n  width: 9,\r\n  height: 9,\r\n  mines: 10,\r\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}